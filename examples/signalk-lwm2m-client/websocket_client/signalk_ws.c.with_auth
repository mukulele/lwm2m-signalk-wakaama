#include <libwebsockets.h>
#include <cjson/cJSON.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

#include "bridge_object.h"
#include "signalk_subscriptions.h"
#include "signalk_auth.h"
#include "signalk_hotreload.h"
#include "signalk_control.h"
#include "signalk_reconnect.h"

static struct lws_context *context;
static struct lws *wsi;
static pthread_t ws_thread;
static int running = 1;
static int subscription_sent = 0;
static int authentication_sent = 0;
static char server_address[256] = "demo.signalk.org";
static int server_port = 3000;

static int callback_signalk(struct lws *wsi,
                            enum lws_callback_reasons reason,
                            void *user, void *in, size_t len)
{
    switch (reason)
    {
    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        printf("[SignalK] Connected to server\n");
        subscription_sent = 0;
        authentication_sent = 0;
        signalk_reconnect_on_connect();  // Notify reconnection system of success
        
        // If authentication is enabled, perform login first
        if (signalk_server_config && signalk_server_config->auth_enabled) {
            printf("[SignalK] Authentication enabled - performing WebSocket login\n");
            lws_callback_on_writable(wsi);
        } else {
            printf("[SignalK] No authentication - sending subscription directly\n");
            signalk_log_subscription_status();
            lws_callback_on_writable(wsi);
        }
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
        // Handle authentication flow first if enabled
        if (signalk_server_config && signalk_server_config->auth_enabled && !authentication_sent) {
            char login_buffer[1024];
            size_t msg_len = signalk_auth_generate_login_message(login_buffer, sizeof(login_buffer));
            if (msg_len > 0) {
                unsigned char buf[LWS_PRE + msg_len];
                memcpy(&buf[LWS_PRE], login_buffer, msg_len);
                
                int n = lws_write(wsi, &buf[LWS_PRE], msg_len, LWS_WRITE_TEXT);
                if (n < 0) {
                    printf("[SignalK] Failed to send authentication\n");
                    return -1;
                }
                printf("[SignalK] Authentication message sent (%zu bytes)\n", msg_len);
                authentication_sent = 1;
            } else {
                printf("[SignalK] Failed to create authentication message\n");
                return -1;
            }
        }
        // Send subscription after authentication (or immediately if no auth)
        else if (!subscription_sent && (!signalk_server_config || !signalk_server_config->auth_enabled || signalk_auth_is_authenticated())) {
            char* subscription_json = NULL;
            if (signalk_create_subscription_message(&subscription_json)) {
                size_t sub_len = strlen(subscription_json);
                unsigned char buf[LWS_PRE + sub_len];
                memcpy(&buf[LWS_PRE], subscription_json, sub_len);
                
                int n = lws_write(wsi, &buf[LWS_PRE], sub_len, LWS_WRITE_TEXT);
                if (n < 0) {
                    printf("[SignalK] Failed to send subscription\n");
                    free(subscription_json);
                    return -1;
                }
                printf("[SignalK] Subscription sent (%zu bytes)\n", sub_len);
                subscription_sent = 1;
                free(subscription_json);
            } else {
                printf("[SignalK] Failed to create subscription message\n");
                return -1;
            }
        }
        break;

    case LWS_CALLBACK_CLIENT_RECEIVE:
    {
        char *msg = strndup((const char *)in, len);
        if (!msg) break;

        // Process authentication responses first if auth is enabled
        if (signalk_server_config && signalk_server_config->auth_enabled) {
            if (signalk_auth_process_response(msg)) {
                if (signalk_auth_is_authenticated()) {
                    printf("[SignalK] Authentication successful - requesting subscription\n");
                    signalk_log_subscription_status();
                    lws_callback_on_writable(wsi);
                    free(msg);
                    break;
                } else {
                    printf("[SignalK] Authentication failed - disabling authentication and retrying\n");
                    printf("[SignalK] This server may not require authentication for read operations\n");
                    signalk_server_config->auth_enabled = false;
                    authentication_sent = 0;
                    signalk_log_subscription_status();
                    lws_callback_on_writable(wsi);
                    free(msg);
                    break;
                }
            }
            // If not an auth response, continue processing as normal message
        }

        // Check for subscription response
        if (signalk_process_subscription_response(msg)) {
            free(msg);
            break;
        }

        cJSON *json = cJSON_Parse(msg);
        free(msg);

        if (json)
        {

            // Signal K "delta" message has an "updates" array
            cJSON *updates = cJSON_GetObjectItem(json, "updates");
            if (cJSON_IsArray(updates))
            {
                cJSON *upd;
                cJSON_ArrayForEach(upd, updates)
                {
                    cJSON *values = cJSON_GetObjectItem(upd, "values");
                    if (cJSON_IsArray(values))
                    {
                        cJSON *val;
                        cJSON_ArrayForEach(val, values)
                        {
                            cJSON *path = cJSON_GetObjectItem(val, "path");
                            cJSON *value = cJSON_GetObjectItem(val, "value");
                            if (cJSON_IsString(path) && value)
                            {
                                char valbuf[64];

                                // Handle navigation.position as a complex object with latitude/longitude
                                if (strcmp(path->valuestring, "navigation.position") == 0 && cJSON_IsObject(value))
                                {
                                    cJSON *latitude = cJSON_GetObjectItem(value, "latitude");
                                    cJSON *longitude = cJSON_GetObjectItem(value, "longitude");
                                    
                                    if (cJSON_IsNumber(latitude))
                                    {
                                        snprintf(valbuf, sizeof(valbuf), "%.6f", latitude->valuedouble);
                                        bridge_update("navigation.position.latitude", valbuf);
                                        printf("[SignalK] navigation.position.latitude = %s\n", valbuf);
                                    }
                                    
                                    if (cJSON_IsNumber(longitude))
                                    {
                                        snprintf(valbuf, sizeof(valbuf), "%.6f", longitude->valuedouble);
                                        bridge_update("navigation.position.longitude", valbuf);
                                        printf("[SignalK] navigation.position.longitude = %s\n", valbuf);
                                    }
                                }
                                else if (cJSON_IsNumber(value))
                                {
                                    // High precision for position-related data, normal for others
                                    if (strstr(path->valuestring, "position") || 
                                        strstr(path->valuestring, "latitude") || 
                                        strstr(path->valuestring, "longitude")) {
                                        snprintf(valbuf, sizeof(valbuf), "%.6f", value->valuedouble);
                                    } else {
                                        snprintf(valbuf, sizeof(valbuf), "%.3f", value->valuedouble);
                                    }
                                    bridge_update(path->valuestring, valbuf);
                                    printf("[SignalK] %s = %s\n", path->valuestring, valbuf);
                                }
                                else if (cJSON_IsString(value))
                                {
                                    snprintf(valbuf, sizeof(valbuf), "%s", value->valuestring);
                                    bridge_update(path->valuestring, valbuf);
                                    printf("[SignalK] %s = %s\n", path->valuestring, valbuf);
                                }
                                else
                                {
                                    // Only log unsupported types for debugging if needed
                                    printf("[SignalK] %s = UNSUPPORTED_TYPE\n", path->valuestring);
                                }
                            }
                        }
                    }
                }
            }
            cJSON_Delete(json);
        }
    }
    break;

    case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
        printf("[SignalK] Connection error\n");
        wsi = NULL;  // Reset connection pointer
        signalk_reconnect_on_disconnect();
        break;

    case LWS_CALLBACK_CLOSED:
        printf("[SignalK] Disconnected\n");
        wsi = NULL;  // Reset connection pointer
        signalk_reconnect_on_disconnect();
        break;

    default:
        break;
    }

    return 0;
}

static struct lws_protocols protocols[] = {
    {
        "signalk-protocol",
        callback_signalk,
        0,  // per-session data size
        4096,
    },
    { NULL, NULL, 0, 0 } // terminator
};

static void *ws_loop(void *arg)
{
    printf("[SignalK] WebSocket service loop started with automatic reconnection\n");
    
    while (running && context)
    {
        // Service existing connections
        if (lws_service(context, 100) < 0) {
            printf("[SignalK] WebSocket service error, checking reconnection\n");
        }
        
        // Check if we need to attempt reconnection
        if (signalk_reconnect_is_enabled() && !wsi && signalk_reconnect_should_retry()) {
            printf("[SignalK] Attempting automatic reconnection...\n");
            
            struct lws_client_connect_info ccinfo;
            memset(&ccinfo, 0, sizeof(ccinfo));
            ccinfo.context = context;
            ccinfo.address = server_address;
            ccinfo.port = server_port;
            ccinfo.path = "/signalk/v1/stream";
            ccinfo.host = ccinfo.address;
            ccinfo.origin = ccinfo.address;
            ccinfo.protocol = protocols[0].name;
            
            wsi = lws_client_connect_via_info(&ccinfo);
            if (!wsi) {
                printf("[SignalK] Reconnection attempt failed\n");
                signalk_reconnect_attempt(server_address, server_port);
            } else {
                printf("[SignalK] Reconnection attempt initiated\n");
            }
        }
        
        // Small delay to prevent busy waiting
        usleep(10000); // 10ms
    }
    printf("[SignalK] WebSocket service loop ended\n");
    return NULL;
}

int signalk_ws_start(const char *server, int port, const char *settings_file)
{
    struct lws_context_creation_info info;
    struct lws_client_connect_info ccinfo;

    // Store server info for reconnection
    strncpy(server_address, server, sizeof(server_address) - 1);
    server_address[sizeof(server_address) - 1] = '\0';
    server_port = port;

    // Use provided settings file path, or default to current directory
    const char *config_file = settings_file ? settings_file : "settings.json";
    
    // Initialize reconnection system
    printf("[SignalK] Initializing automatic reconnection system...\n");
    if (!signalk_reconnect_load_config(config_file)) {
        printf("[SignalK] Warning: Failed to load reconnection config, using defaults\n");
        signalk_reconnect_config_t default_config = signalk_reconnect_get_default_config();
        signalk_reconnect_init(&default_config);
    }
    
    // Load configuration from specified settings file
    if (!signalk_load_config_from_file(config_file)) {
        printf("[SignalK] Error: Failed to load %s\n", config_file);
        printf("[SignalK] SignalK WebSocket client requires a valid settings.json configuration file\n");
        printf("[SignalK] Please ensure %s exists and contains valid JSON configuration\n", config_file);
        return -1;
    }

    // Initialize hot-reload functionality
    printf("[SignalK] Initializing configuration hot-reload for %s...\n", config_file);
    if (signalk_hotreload_init(config_file, 2000)) {
        printf("[SignalK] ✓ Hot-reload enabled (checking every 2s)\n");
        printf("[SignalK] You can now edit %s and changes will be applied automatically\n", config_file);
        
        // Set callback for configuration changes (optional)
        // signalk_hotreload_set_callback(my_config_change_handler);
        
        // Start the hot-reload service thread
        if (!signalk_hotreload_start_service()) {
            printf("[SignalK] Warning: Failed to start hot-reload service thread\n");
        }
    } else {
        printf("[SignalK] Warning: Hot-reload initialization failed\n");
    }

    // Initialize SignalK control system for PUT commands
    printf("[SignalK] Initializing SignalK control system...\n");
    if (signalk_control_load_config(config_file)) {
        printf("[SignalK] ✓ SignalK control system initialized\n");
        
        // Test connection to SignalK server (optional, non-blocking)
        if (signalk_control_test_connection()) {
            printf("[SignalK] ✓ SignalK HTTP API is accessible\n");
        } else {
            printf("[SignalK] ⚠ SignalK HTTP API not accessible (this is normal if server requires authentication)\n");
        }
    } else {
        printf("[SignalK] Warning: SignalK control system initialization failed\n");
        printf("[SignalK] LwM2M→SignalK control will not be available\n");
    }
    
    // Initialize SignalK authentication system if enabled
    if (signalk_server_config && signalk_server_config->auth_enabled) {
        printf("[SignalK] Initializing authentication system...\n");
        signalk_auth_config_t auth_config = {0};
        auth_config.enabled = true;
        strncpy(auth_config.username, signalk_server_config->username, sizeof(auth_config.username) - 1);
        strncpy(auth_config.password, signalk_server_config->password, sizeof(auth_config.password) - 1);
        auth_config.token_renewal_time = signalk_server_config->token_renewal_time;
        
        if (signalk_auth_init(&auth_config)) {
            printf("[SignalK] ✓ Authentication system initialized\n");
        } else {
            printf("[SignalK] Error: Failed to initialize authentication system\n");
            return -1;
        }
    } else {
        printf("[SignalK] Authentication disabled - operating in anonymous mode\n");
    }

    // Check if we have any subscriptions
    if (signalk_subscription_count == 0) {
        printf("[SignalK] Warning: No subscriptions configured, SignalK data will not be received\n");
        printf("[SignalK] Please check settings.json for subscription configuration\n");
    }

    // Reset subscription state
    subscription_sent = 0;

    memset(&info, 0, sizeof(info));
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;

    context = lws_create_context(&info);
    if (!context) {
        fprintf(stderr, "[SignalK] Failed to create context\n");
        return -1;
    }

    // Use configuration from settings.json or fallback
    const char* target_server = signalk_server_config ? signalk_server_config->host : (server ? server : "127.0.0.1");
    int target_port = signalk_server_config ? signalk_server_config->port : (port > 0 ? port : 3000);
    char connection_path[600];
    
    if (signalk_server_config) {
        snprintf(connection_path, sizeof(connection_path), "%s?subscribe=%s", 
                signalk_server_config->path, signalk_server_config->subscribe_mode);
    } else {
        strcpy(connection_path, "/signalk/v1/stream?subscribe=none");
    }

    memset(&ccinfo, 0, sizeof(ccinfo));
    ccinfo.context = context;
    ccinfo.address = target_server;
    ccinfo.port = target_port;
    ccinfo.path = connection_path;
    ccinfo.host = lws_canonical_hostname(context);
    ccinfo.origin = "origin";
    ccinfo.protocol = protocols[0].name;

    wsi = lws_client_connect_via_info(&ccinfo);
    if (!wsi) {
        fprintf(stderr, "[SignalK] Failed to connect to %s:%d\n", server, port);
        lws_context_destroy(context);
        context = NULL;
        return -1;
    }

    running = 1;
    if (pthread_create(&ws_thread, NULL, ws_loop, NULL) != 0) {
        fprintf(stderr, "[SignalK] Failed to create thread\n");
        lws_context_destroy(context);
        context = NULL;
        wsi = NULL;
        return -1;
    }
    
    return 0;
}

void signalk_ws_stop(void)
{
    if (running) {
        printf("[SignalK] Stopping WebSocket client...\n");
        running = 0;
        
        // Give the thread a moment to check the running flag
        usleep(100000); // 100ms
        
        if (ws_thread) {
            printf("[SignalK] Waiting for WebSocket thread to finish...\n");
            pthread_join(ws_thread, NULL);
            ws_thread = 0;
        }
    }
    
    if (context) {
        printf("[SignalK] Destroying WebSocket context...\n");
        lws_context_destroy(context);
        context = NULL;
    }
    
    // Cleanup SignalK control system
    printf("[SignalK] Cleaning up SignalK control system...\n");
    signalk_control_cleanup();
    
    // Cleanup authentication system
    printf("[SignalK] Cleaning up authentication system...\n");
    signalk_auth_cleanup();
    
    // Cleanup reconnection system
    printf("[SignalK] Cleaning up reconnection system...\n");
    signalk_reconnect_cleanup();
    
    // Cleanup hot-reload system
    printf("[SignalK] Cleaning up hot-reload system...\n");
    signalk_hotreload_stop_service();
    wsi = NULL;
    
    // Stop hot-reload service and clean up
    printf("[SignalK] Stopping hot-reload service...\n");
    signalk_hotreload_stop_service();
    signalk_hotreload_cleanup();
    
    // Clean up configuration
    signalk_free_config();
    
    printf("[SignalK] WebSocket client stopped\n");
}
